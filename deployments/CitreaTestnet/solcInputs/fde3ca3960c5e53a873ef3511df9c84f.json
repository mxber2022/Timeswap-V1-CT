{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/callback/ITimeswapBorrowCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\n\n/// @title Callback for ITimeswapPair#borrow\n/// @notice Any contract that calls ITimeswapPair#borrow must implement this interface\ninterface ITimeswapBorrowCallback {\n    /// @notice Called to `msg.sender` after initiating a borrow from ITimeswapPair#borrow.\n    /// @dev In the implementation you must pay the collateral token owed for the borrow transaction.\n    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.\n    /// @param collateralIn The amount of asset tokens owed due to the pool for the borrow transaction\n    /// @param data Any data passed through by the caller via the ITimeswapPair#borrow call\n    function timeswapBorrowCallback(\n        uint112 collateralIn,\n        bytes calldata data\n    ) external;\n}"
    },
    "contracts/test/TimeswapPairCallee.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.4;\n\nimport {IPair} from '../interfaces/IPair.sol';\nimport {IFactory} from '../interfaces/IFactory.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ITimeswapBorrowCallback} from '../interfaces/callback/ITimeswapBorrowCallback.sol';\nimport {ITimeswapLendCallback} from '../interfaces/callback/ITimeswapLendCallback.sol';\nimport {ITimeswapMintCallback} from '../interfaces/callback/ITimeswapMintCallback.sol';\nimport {ITimeswapPayCallback} from '../interfaces/callback/ITimeswapPayCallback.sol';\n\n\n\ncontract TimeswapPairCallee {\n    IPair public immutable  pairContract;\n    IFactory public immutable  factoryContract;\n\n    constructor(address pair) {\n        pairContract = IPair(pair);\n        factoryContract = IPair(pair).factory();\n    }\n    \n    struct PairCalleeInfo {\n        IERC20 asset;\n        IERC20 collateral;\n        address from;\n    }\n    struct PairCalleeInfoMint {\n        IERC20 asset;\n        IERC20 collateral;\n        address assetFrom;\n        address collateralFrom;\n    }\n\n    function getData(address from) public view returns (bytes memory data) {\n        data = abi.encode(PairCalleeInfo(pairContract.asset(),pairContract.collateral(),from));\n    }\n\n    function getDataMint(address from) public view returns (bytes memory data){\n        data =  abi.encode(PairCalleeInfoMint(pairContract.asset(),pairContract.collateral(),from,from));\n    }\n\n    function mint(\n        uint256 maturity,\n        address liquidityTo,\n        uint112 xIncrease,\n        uint112 yIncrease,\n        uint112 zIncrease\n    )\n        external \n        returns (\n            uint256 assetIn,\n            uint256 liquidityOut,\n            uint256 id,\n            IPair.Due memory dueOut\n        )\n    {   \n        return pairContract.mint(\n            IPair.MintParam(\n                maturity,\n                liquidityTo,\n                address(this),\n                xIncrease,\n                yIncrease,\n                zIncrease,\n                getDataMint(msg.sender)\n            )\n        );\n    }\n\n    function lend(\n        uint256 maturity,\n        address bondTo,\n        address insuranceTo,\n        uint112 xIncrease,\n        uint112 yDecrease,\n        uint112 zDecrease\n    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut){\n        return pairContract.lend(\n            IPair.LendParam(\n                maturity,\n                bondTo,\n                insuranceTo,\n                xIncrease,\n                yDecrease,\n                zDecrease,\n                getData(msg.sender)\n            )\n        );\n    }\n\n    function borrow(\n        uint256 maturity,\n        address assetTo,\n        address dueTo,\n        uint112 xDecrease,\n        uint112 yIncrease,\n        uint112 zIncrease\n    ) external returns (uint256 assetOut, uint256 id, IPair.Due memory dueOut){\n        return pairContract.borrow(\n            IPair.BorrowParam(\n                maturity,\n                assetTo,\n                dueTo,\n                xDecrease,\n                yIncrease,\n                zIncrease,\n                getData(msg.sender)\n            )\n        );\n    }\n\n    function pay(\n        uint256 maturity,\n        address to,\n        address owner,\n        uint256[] memory ids,\n        uint112[] memory assetsIn,\n        uint112[] memory collateralsOut\n    ) external returns (uint128 assetIn, uint128 collateralOut){\n        return pairContract.pay(\n            IPair.PayParam(\n                maturity,\n                to,\n                owner,\n                ids,\n                assetsIn,\n                collateralsOut,\n                getData(msg.sender)\n            )\n        );\n    }\n\n    function timeswapMintCallback(\n        uint256 assetIn,\n        uint112 collateralIn,\n        bytes calldata data\n    ) external {\n        (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode(\n            data,\n            (IERC20, IERC20, address, address)\n        );\n        IPair pair = factoryContract.getPair(asset, collateral);\n\n        require(msg.sender == address(pair), 'Invalid sender');\n        asset.transferFrom(assetFrom, address(pair), assetIn);\n        collateral.transferFrom(collateralFrom, address(pair), collateralIn);\n    }\n\n    function timeswapLendCallback(uint256 assetIn, bytes calldata data) external {\n        (IERC20 asset, IERC20 collateral, address from) = abi.decode(\n            data,\n            (IERC20, IERC20, address)\n        );\n        IPair pair = factoryContract.getPair(asset, collateral);\n\n        require(msg.sender == address(pair), 'Invalid sender');\n        asset.transferFrom(from, address(pair), assetIn);\n    }\n\n    function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external {\n        (IERC20 asset, IERC20 collateral, address from) = abi.decode(\n            data,\n            (IERC20, IERC20, address)\n        );\n        IPair pair = factoryContract.getPair(asset, collateral);\n\n        require(msg.sender == address(pair), 'Invalid sender');\n        collateral.transferFrom(from, address(pair), collateralIn);\n    }\n    \n    function timeswapPayCallback(\n        uint128 assetIn,\n        bytes calldata data\n    ) external {\n        (IERC20 asset, IERC20 collateral, address from) = abi.decode(\n            data,\n            (IERC20, IERC20, address)\n        );\n        IPair pair = factoryContract.getPair(asset, collateral);\n        asset.transferFrom(from, address(pair), assetIn);\n        \n    }\n}"
    },
    "contracts/interfaces/IPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\n\nimport {IFactory} from './IFactory.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IPair {\n    /* ===== STRUCT ===== */\n\n    struct Tokens {\n        uint128 asset;\n        uint128 collateral;\n    }\n\n    struct Claims {\n        uint112 bondPrincipal;\n        uint112 bondInterest;\n        uint112 insurancePrincipal;\n        uint112 insuranceInterest;\n    }\n\n    struct Due {\n        uint112 debt;\n        uint112 collateral;\n        uint32 startBlock;\n    }\n\n    struct State {\n        Tokens reserves;\n        uint256 feeStored;\n        uint256 totalLiquidity;\n        Claims totalClaims;\n        uint120 totalDebtCreated;\n        uint112 x;\n        uint112 y;\n        uint112 z;\n    }\n\n    struct Pool {\n        State state;\n        mapping(address => uint256) liquidities;\n        mapping(address => Claims) claims;\n        mapping(address => Due[]) dues;\n    }\n\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param liquidityTo The address of the receiver of liquidity balance.\n    /// @param dueTo The addres of the receiver of collateralized debt balance.\n    /// @param xIncrease The increase in the X state.\n    /// @param yIncrease The increase in the Y state.\n    /// @param zIncrease The increase in the Z state.\n    /// @param data The data for callback.\n    struct MintParam {\n        uint256 maturity;\n        address liquidityTo;\n        address dueTo;\n        uint112 xIncrease;\n        uint112 yIncrease;\n        uint112 zIncrease;\n        bytes data;\n    }\n\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param assetTo The address of the receiver of asset ERC20.\n    /// @param collateralTo The addres of the receiver of collateral ERC20.\n    /// @param liquidityIn The amount of liquidity balance burnt by the msg.sender.\n    struct BurnParam {\n        uint256 maturity;\n        address assetTo;\n        address collateralTo;\n        uint256 liquidityIn;\n    }\n\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param bondTo The address of the receiver of bond balance.\n    /// @param insuranceTo The addres of the receiver of insurance balance.\n    /// @param xIncrease The increase in x state and the amount of asset ERC20 sent.\n    /// @param yDecrease The decrease in y state.\n    /// @param zDecrease The decrease in z state.\n    /// @param data The data for callback.\n    struct LendParam {\n        uint256 maturity;\n        address bondTo;\n        address insuranceTo;\n        uint112 xIncrease;\n        uint112 yDecrease;\n        uint112 zDecrease;\n        bytes data;\n    }\n\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param assetTo The address of the receiver of asset ERC20.\n    /// @param collateralTo The addres of the receiver of collateral ERC20.\n    /// @param claimsIn The amount of bond balance and insurance balance burnt by the msg.sender.\n    struct WithdrawParam {\n        uint256 maturity;\n        address assetTo;\n        address collateralTo;\n        Claims claimsIn;\n    }\n\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param assetTo The address of the receiver of asset ERC20.\n    /// @param dueTo The address of the receiver of collateralized debt.\n    /// @param xDecrease The decrease in x state and amount of asset ERC20 received by assetTo.\n    /// @param yIncrease The increase in y state.\n    /// @param zIncrease The increase in z state.\n    /// @param data The data for callback.\n    struct BorrowParam {\n        uint256 maturity;\n        address assetTo;\n        address dueTo;\n        uint112 xDecrease;\n        uint112 yIncrease;\n        uint112 zIncrease;\n        bytes data;\n    }\n\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param to The address of the receiver of collateral ERC20.\n    /// @param owner The addres of the owner of collateralized debt.\n    /// @param ids The array indexes of collateralized debts.\n    /// @param assetsIn The amount of asset ERC20 paid per collateralized debts.\n    /// @param collateralsOut The amount of collateral ERC20 withdrawn per collaterlaized debts.\n    /// @param data The data for callback.\n    struct PayParam {\n        uint256 maturity;\n        address to;\n        address owner;\n        uint256[] ids;\n        uint112[] assetsIn;\n        uint112[] collateralsOut;\n        bytes data;\n    }\n\n    /* ===== EVENT ===== */\n\n    /// @dev Emits when the state gets updated.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param x The new x state of the pool.\n    /// @param y The new y state of the pool.\n    /// @param z The new z state of the pool.\n    event Sync(uint256 indexed maturity, uint112 x, uint112 y, uint112 z);\n\n    /// @dev Emits when mint function is called.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param sender The address of the caller.\n    /// @param liquidityTo The address of the receiver of liquidity balance.\n    /// @param dueTo The address of the receiver of collateralized debt balance.\n    /// @param assetIn The increase in the X state.\n    /// @param liquidityOut The amount of liquidity balance received by liquidityTo.\n    /// @param id The array index of the collateralized debt received by dueTo.\n    /// @param dueOut The collateralized debt received by dueTo.\n    /// @param feeIn The amount of fee asset ERC20 deposited.\n    event Mint(\n        uint256 maturity,\n        address indexed sender,\n        address indexed liquidityTo,\n        address indexed dueTo,\n        uint256 assetIn,\n        uint256 liquidityOut,\n        uint256 id,\n        Due dueOut,\n        uint256 feeIn\n    );\n\n    /// @dev Emits when burn function is called.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param sender The address of the caller.\n    /// @param assetTo The address of the receiver of asset ERC20.\n    /// @param collateralTo The addres of the receiver of collateral ERC20.\n    /// @param liquidityIn The amount of liquidity balance burnt by the sender.\n    /// @param assetOut The amount of asset ERC20 received.\n    /// @param collateralOut The amount of collateral ERC20 received.\n    /// @param feeOut The amount of fee asset ERC20 received.\n    event Burn(\n        uint256 maturity,\n        address indexed sender,\n        address indexed assetTo,\n        address indexed collateralTo,\n        uint256 liquidityIn,\n        uint256 assetOut,\n        uint128 collateralOut,\n        uint256 feeOut\n    );\n\n    /// @dev Emits when lend function is called.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param sender The address of the caller.\n    /// @param bondTo The address of the receiver of bond balance.\n    /// @param insuranceTo The addres of the receiver of insurance balance.\n    /// @param assetIn The increase in X state.\n    /// @param claimsOut The amount of bond balance and insurance balance received.\n    /// @param feeIn The amount of fee paid by lender.\n    /// @param protocolFeeIn The amount of protocol fee paid by lender.\n    event Lend(\n        uint256 maturity,\n        address indexed sender,\n        address indexed bondTo,\n        address indexed insuranceTo,\n        uint256 assetIn,\n        Claims claimsOut,\n        uint256 feeIn,\n        uint256 protocolFeeIn\n    );\n\n    /// @dev Emits when withdraw function is called.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param sender The address of the caller.\n    /// @param assetTo The address of the receiver of asset ERC20.\n    /// @param collateralTo The address of the receiver of collateral ERC20.\n    /// @param claimsIn The amount of bond balance and insurance balance burnt by the sender.\n    /// @param tokensOut The amount of asset ERC20 and collateral ERC20 received.\n    event Withdraw(\n        uint256 maturity,\n        address indexed sender,\n        address indexed assetTo,\n        address indexed collateralTo,\n        Claims claimsIn,\n        Tokens tokensOut\n    );\n\n    /// @dev Emits when borrow function is called.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param sender The address of the caller.\n    /// @param assetTo The address of the receiver of asset ERC20.\n    /// @param dueTo The address of the receiver of collateralized debt.\n    /// @param assetOut The amount of asset ERC20 received by assetTo.\n    /// @param id The array index of the collateralized debt received by dueTo.\n    /// @param dueOut The collateralized debt received by dueTo.\n    /// @param feeIn The amount of fee paid by lender.\n    /// @param protocolFeeIn The amount of protocol fee paid by lender.\n    event Borrow(\n        uint256 maturity,\n        address indexed sender,\n        address indexed assetTo,\n        address indexed dueTo,\n        uint256 assetOut,\n        uint256 id,\n        Due dueOut,\n        uint256 feeIn,\n        uint256 protocolFeeIn\n    );\n\n    /// @dev Emits when pay function is called.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param sender The address of the caller.\n    /// @param to The address of the receiver of collateral ERC20.\n    /// @param owner The address of the owner of collateralized debt.\n    /// @param ids The array indexes of collateralized debts.\n    /// @param assetsIn The amount of asset ERC20 paid per collateralized debts.\n    /// @param collateralsOut The amount of collateral ERC20 withdrawn per collaterelized debts.\n    /// @param assetIn The total amount of asset ERC20 paid.\n    /// @param collateralOut The total amount of collateral ERC20 received.\n    event Pay(\n        uint256 maturity,\n        address indexed sender,\n        address indexed to,\n        address indexed owner,\n        uint256[] ids,\n        uint112[] assetsIn,\n        uint112[] collateralsOut,\n        uint128 assetIn,\n        uint128 collateralOut\n    );\n\n    /// @dev Emits when collectProtocolFee function is called\n    /// @param sender The address of the caller.\n    /// @param to The address of the receiver of asset ERC20.\n    /// @param protocolFeeOut The amount of protocol fee asset ERC20 received.\n    event CollectProtocolFee(\n        address indexed sender,\n        address indexed to,\n        uint256 protocolFeeOut\n    );\n\n    /* ===== VIEW ===== */\n\n    /// @dev Return the address of the factory contract that deployed this contract.\n    /// @return The address of the factory contract.\n    function factory() external view returns (IFactory);\n\n    /// @dev Return the address of the ERC20 being lent and borrowed.\n    /// @return The address of the asset ERC20.\n    function asset() external view returns (IERC20);\n\n    /// @dev Return the address of the ERC20 as collateral.\n    /// @return The address of the collateral ERC20.\n    function collateral() external view returns (IERC20);\n\n    //// @dev Return the fee per second earned by liquidity providers.\n    /// @dev Must be downcasted to uint16.\n    //// @return The transaction fee following the UQ0.40 format.\n    function fee() external view returns (uint256);\n\n    /// @dev Return the protocol fee per second earned by the owner.\n    /// @dev Must be downcasted to uint16.\n    /// @return The protocol fee per second following the UQ0.40 format.\n    function protocolFee() external view returns (uint256);\n\n    /// @dev Return the fee stored of the Pool given maturity.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @return The fee in asset ERC20 stored in the Pool.\n    function feeStored(uint256 maturity) external view returns (uint256);\n\n    /// @dev Return the protocol fee stored.\n    /// @return The protocol fee in asset ERC20 stored.\n    function protocolFeeStored() external view returns (uint256);\n\n    /// @dev Returns the Constant Product state of a Pool.\n    /// @dev The Y state follows the UQ80.32 format.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @return x The x state.\n    /// @return y The y state.\n    /// @return z The z state.\n    function constantProduct(uint256 maturity)\n        external\n        view\n        returns (\n            uint112 x,\n            uint112 y,\n            uint112 z\n        );\n\n    /// @dev Returns the asset ERC20 and collateral ERC20 balances of a Pool.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @return The asset ERC20 and collateral ERC20 locked.\n    function totalReserves(uint256 maturity) external view returns (Tokens memory);\n\n    /// @dev Returns the total liquidity supply of a Pool.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @return The total liquidity supply.\n    function totalLiquidity(uint256 maturity) external view returns (uint256);\n\n    /// @dev Returns the liquidity balance of a user in a Pool.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param owner The address of the user.\n    /// @return The liquidity balance.\n    function liquidityOf(uint256 maturity, address owner) external view returns (uint256);\n\n    /// @dev Returns the total claims of a Pool.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @return The total claims.\n    function totalClaims(uint256 maturity) external view returns (Claims memory);\n\n    /// @dev Returms the claims of a user in a Pool.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param owner The address of the user.\n    /// @return The claims balance.\n    function claimsOf(uint256 maturity, address owner) external view returns (Claims memory);\n\n    /// @dev Returns the total debt created.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @return The total asset ERC20 debt created.\n    function totalDebtCreated(uint256 maturity) external view returns (uint120);\n\n    /// @dev Returns the number of dues owned by owner.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param owner The address of the user.\n    function totalDuesOf(uint256 maturity, address owner) external view returns (uint256);\n\n    /// @dev Returns a collateralized debt of a user in a Pool.\n    /// @param maturity The unix timestamp maturity of the Pool.\n    /// @param owner The address of the user.\n    /// @param id The index of the collateralized debt\n    /// @return The collateralized debt balance.\n    function dueOf(uint256 maturity, address owner, uint256 id) external view returns (Due memory);\n\n    /* ===== UPDATE ===== */\n\n    /// @dev Add liquidity into a Pool by a liquidity provider.\n    /// @dev Liquidity providers can be thought as making both lending and borrowing positions.\n    /// @dev Must be called by a contract implementing the ITimeswapMintCallback interface.\n    /// @param param The mint parameter found in the MintParam struct.\n    /// @return assetIn The amount of asset ERC20 deposited.\n    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.\n    /// @return id The array index of the collateralized debt received by dueTo.\n    /// @return dueOut The collateralized debt received by dueTo.\n    function mint(MintParam calldata param)\n        external\n        returns (\n            uint256 assetIn,\n            uint256 liquidityOut,\n            uint256 id,\n            Due memory dueOut\n        );\n\n    /// @dev Remove liquidity from a Pool by a liquidity provider.\n    /// @dev Can only be called after the maturity of the Pool.\n    /// @param param The burn parameter found in the BurnParam struct.\n    /// @return assetOut The amount of asset ERC20 received.\n    /// @return collateralOut The amount of collateral ERC20 received.\n    function burn(BurnParam calldata param) \n        external \n        returns (\n            uint256 assetOut,\n            uint128 collateralOut \n        );\n\n    /// @dev Lend asset ERC20 into the Pool.\n    /// @dev Must be called by a contract implementing the ITimeswapLendCallback interface.\n    /// @param param The lend parameter found in the LendParam struct.\n    /// @return assetIn The amount of asset ERC20 deposited.\n    /// @return claimsOut The amount of bond balance and insurance balance received.\n    function lend(LendParam calldata param) \n        external \n        returns (\n            uint256 assetIn,\n            Claims memory claimsOut\n        );\n\n    /// @dev Withdraw asset ERC20 and/or collateral ERC20 for lenders.\n    /// @dev Can only be called after the maturity of the Pool.\n    /// @param param The withdraw parameter found in the WithdrawParam struct.\n    /// @return tokensOut The amount of asset ERC20 and collateral ERC20 received.\n    function withdraw(WithdrawParam calldata param)\n        external \n        returns (\n            Tokens memory tokensOut\n        );\n\n    /// @dev Borrow asset ERC20 from the Pool.\n    /// @dev Must be called by a contract implementing the ITimeswapBorrowCallback interface.\n    /// @param param The borrow parameter found in the BorrowParam struct.\n    /// @return assetOut The amount of asset ERC20 received.\n    /// @return id The array index of the collateralized debt received by dueTo.\n    /// @return dueOut The collateralized debt received by dueTo.\n    function borrow(BorrowParam calldata param)\n        external \n        returns (\n            uint256 assetOut,\n            uint256 id, \n            Due memory dueOut\n        );\n\n    /// @dev Pay asset ERC20 into the Pool to repay debt for borrowers.\n    /// @dev If there are asset paid, must be called by a contract implementing the ITimeswapPayCallback interface.\n    /// @param param The pay parameter found in the PayParam struct.\n    /// @return assetIn The total amount of asset ERC20 paid.\n    /// @return collateralOut The total amount of collateral ERC20 received.\n    function pay(PayParam calldata param)\n        external \n        returns (\n            uint128 assetIn, \n            uint128 collateralOut\n        );\n\n    /// @dev Collect the stored protocol fee.\n    /// @dev Can only be called by the owner.\n    /// @param to The receiver of the protocol fee.\n    /// @return protocolFeeOut The total amount of protocol fee asset ERC20 received.\n    function collectProtocolFee(address to) external returns (uint256 protocolFeeOut);\n}\n"
    },
    "contracts/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\n\nimport {IPair} from './IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IFactory {\n    /* ===== EVENT ===== */\n\n    /// @dev Emits when a new Timeswap Pair contract is created.\n    /// @param asset The address of the ERC20 being lent and borrowed.\n    /// @param collateral The address of the ERC20 used as collateral.\n    /// @param pair The address of the Timeswap Pair contract created.\n    event CreatePair(IERC20 indexed asset, IERC20 indexed collateral, IPair pair);\n\n    /// @dev Emits when a new pending owner is set.\n    /// @param pendingOwner The address of the new pending owner.\n    event SetOwner(address indexed pendingOwner);\n\n    /// @dev Emits when the pending owner has accepted being the new owner.\n    /// @param owner The address of the new owner.\n    event AcceptOwner(address indexed owner);\n\n    /* ===== VIEW ===== */\n\n    /// @dev Return the address that receives the protocol fee.\n    /// @return The address of the owner.\n    function owner() external view returns (address);\n\n    /// @dev Return the new pending address to replace the owner.\n    /// @return The address of the pending owner.\n    function pendingOwner() external view returns (address);\n\n    /// @dev Return the fee per second earned by liquidity providers.\n    /// @dev Must be downcasted to uint16.\n    /// @return The fee following UQ0.40 format.\n    function fee() external view returns (uint256);\n\n    /// @dev Return the protocol fee per second earned by the owner.\n    /// @dev Must be downcasted to uint16.\n    /// @return The protocol fee per second following UQ0.40 format.\n    function protocolFee() external view returns (uint256);\n\n    /// @dev Returns the address of a deployed pair.\n    /// @param asset The address of the ERC20 being lent and borrowed.\n    /// @param collateral The address of the ERC20 used as collateral.\n    /// @return pair The address of the Timeswap Pair contract.\n    function getPair(IERC20 asset, IERC20 collateral) external view returns (IPair pair);\n\n    /* ===== UPDATE ===== */\n\n    /// @dev Creates a Timeswap Pool based on ERC20 pair parameters.\n    /// @dev Cannot create a Timeswap Pool with the same pair parameters.\n    /// @param asset The address of the ERC20 being lent and borrowed.\n    /// @param collateral The address of the ERC20 as the collateral.\n    /// @return pair The address of the Timeswap Pair contract.\n    function createPair(IERC20 asset, IERC20 collateral) external returns (IPair pair);\n\n    /// @dev Set the pending owner of the factory.\n    /// @dev Can only be called by the current owner.\n    /// @param _pendingOwner the chosen pending owner.\n    function setPendingOwner(address _pendingOwner) external;\n\n    /// @dev Set the pending owner as the owner of the factory.\n    /// @dev Reset the pending owner to zero.\n    /// @dev Can only be called by the pending owner.\n    function acceptOwner() external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/callback/ITimeswapLendCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\n\n/// @title Callback for ITimeswapPair#lend\n/// @notice Any contract that calls ITimeswapPair#lend must implement this interface\ninterface ITimeswapLendCallback {\n    /// @notice Called to `msg.sender` after initiating a lend from ITimeswapPair#lend.\n    /// @dev In the implementation you must pay the asset token owed for the lend transaction.\n    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.\n    /// @param assetIn The amount of asset tokens owed due to the pool for the lend transaction\n    /// @param data Any data passed through by the caller via the ITimeswapPair#lend call\n    function timeswapLendCallback(\n        uint256 assetIn,\n        bytes calldata data\n    ) external;\n}"
    },
    "contracts/interfaces/callback/ITimeswapMintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\n\n/// @title Callback for ITimeswapPair#mint\n/// @notice Any contract that calls ITimeswapPair#mint must implement this interface\ninterface ITimeswapMintCallback {\n    /// @notice Called to `msg.sender` after initiating a mint from ITimeswapPair#mint.\n    /// @dev In the implementation you must pay the asset token and collateral token owed for the mint transaction.\n    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.\n    /// @param assetIn The amount of asset tokens owed due to the pool for the mint transaction.\n    /// @param collateralIn The amount of collateral tokens owed due to the pool for the min transaction.\n    /// @param data Any data passed through by the caller via the ITimeswapPair#mint call\n    function timeswapMintCallback(\n        uint256 assetIn,\n        uint112 collateralIn,\n        bytes calldata data\n    ) external;\n}"
    },
    "contracts/interfaces/callback/ITimeswapPayCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\n\n/// @title Callback for ITimeswapPair#pay\n/// @notice Any contract that calls ITimeswapPair#pay must implement this interface\ninterface ITimeswapPayCallback {\n    /// @notice Called to `msg.sender` after initiating a pay from ITimeswapPair#pay.\n    /// @dev In the implementation you must pay the asset token owed for the pay transaction.\n    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.\n    /// @param assetIn The amount of asset tokens owed due to the pool for the pay transaction\n    /// @param data Any data passed through by the caller via the ITimeswapPair#pay call\n    function timeswapPayCallback(\n        uint128 assetIn,\n        bytes calldata data\n    ) external;\n}"
    },
    "contracts/test/libraries/CallbackTestCallee.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.4;\n\nimport {CallbackTest} from './CallbackTest.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ITimeswapBorrowCallback} from '../../interfaces/callback/ITimeswapBorrowCallback.sol';\nimport {ITimeswapLendCallback} from '../../interfaces/callback/ITimeswapLendCallback.sol';\nimport {ITimeswapMintCallback} from '../../interfaces/callback/ITimeswapMintCallback.sol';\nimport {ITimeswapPayCallback} from '../../interfaces/callback/ITimeswapPayCallback.sol';\n\ncontract CallbackTestCallee {\n    CallbackTest public immutable callbackTestContract;\n\n    constructor(address callbackTest) {\n        callbackTestContract = CallbackTest(callbackTest);\n    }\n\n    function mint(\n        IERC20 asset,\n        IERC20 collateral,\n        uint256 assetIn,\n        uint112 collateralIn,\n        bytes calldata data\n    ) external returns (bool) {\n        callbackTestContract.mint(\n            asset,\n            collateral,\n            assetIn,\n            collateralIn,\n            data\n        );\n        return true;\n    }\n\n    function lend(\n        IERC20 asset,\n        uint256 assetIn,\n        bytes calldata data\n    ) external returns (bool) {\n        callbackTestContract.lend(\n            asset,\n            assetIn,\n            data\n        );\n        return true;\n    }\n\n    function borrow(\n        IERC20 collateral,\n        uint112 collateralIn,\n        bytes calldata data\n    ) external returns (bool) {\n        callbackTestContract.borrow(\n            collateral,\n            collateralIn,\n            data\n        );\n        return true;\n    }\n\n    function pay(\n        IERC20 asset,\n        uint128 assetIn,\n        bytes calldata data\n    ) external returns (bool) {\n        callbackTestContract.pay(\n            asset,\n            assetIn,\n            data\n        );\n        return true;\n    }\n    \n    function timeswapMintCallback(\n        uint256 assetIn,\n        uint112 collateralIn,\n        bytes calldata data\n    ) external {}\n\n    function timeswapLendCallback(\n        uint256 assetIn,\n        bytes calldata data\n    ) external {}\n\n    function timeswapBorrowCallback(\n        uint112 collateralIn,\n        bytes calldata data\n    ) external {}\n\n    function timeswapPayCallback(\n        uint128 assetIn,\n        bytes calldata data\n    ) external {}\n}"
    },
    "contracts/test/libraries/CallbackTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.4;\n\nimport {Callback} from '../../libraries/Callback.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract CallbackTest {\n    function mint(\n        IERC20 asset,\n        IERC20 collateral,\n        uint256 assetIn,\n        uint112 collateralIn,\n        bytes calldata data\n    ) external {\n        Callback.mint(\n            asset,\n            collateral,\n            assetIn,\n            collateralIn,\n            data\n        );\n    }\n\n    function lend(\n        IERC20 asset,\n        uint256 assetIn,\n        bytes calldata data\n    ) external {\n        Callback.lend(\n            asset,\n            assetIn,\n            data\n        );\n    }\n\n    function borrow(\n        IERC20 collateral,\n        uint112 collateralIn,\n        bytes calldata data\n    ) external {\n        Callback.borrow(\n            collateral,\n            collateralIn,\n            data\n        );\n    }\n\n    function pay(\n        IERC20 asset,\n        uint128 assetIn,\n        bytes calldata data\n    ) external {\n        Callback.pay(\n            asset,\n            assetIn,\n            data\n        );\n    }\n}"
    },
    "contracts/libraries/Callback.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.4;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ITimeswapMintCallback} from '../interfaces/callback/ITimeswapMintCallback.sol';\nimport {ITimeswapLendCallback} from '../interfaces/callback/ITimeswapLendCallback.sol';\nimport {ITimeswapBorrowCallback} from '../interfaces/callback/ITimeswapBorrowCallback.sol';\nimport {ITimeswapPayCallback} from '../interfaces/callback/ITimeswapPayCallback.sol';\nimport {SafeBalance} from './SafeBalance.sol';\nimport {SafeCast} from './SafeCast.sol';\n\nlibrary Callback {\n    using SafeBalance for IERC20;\n    using SafeCast for uint256;\n\n    function mint(\n        IERC20 asset,\n        IERC20 collateral,\n        uint256 assetIn,\n        uint112 collateralIn,\n        bytes calldata data\n    ) internal {\n        uint256 assetReserve = asset.safeBalance();\n        uint256 collateralReserve = collateral.safeBalance();\n        ITimeswapMintCallback(msg.sender).timeswapMintCallback(assetIn, collateralIn, data);\n        uint256 _assetReserve = asset.safeBalance();\n        uint256 _collateralReserve = collateral.safeBalance();\n        require(_assetReserve >= assetReserve + assetIn, 'E304');\n        require(_collateralReserve >= collateralReserve + collateralIn, 'E305');\n    }\n\n    function lend(\n        IERC20 asset,\n        uint256 assetIn,\n        bytes calldata data\n    ) internal {\n        uint256 assetReserve = asset.safeBalance();\n        ITimeswapLendCallback(msg.sender).timeswapLendCallback(assetIn, data);\n        uint256 _assetReserve = asset.safeBalance();\n        require(_assetReserve >= assetReserve + assetIn, 'E304');\n    }\n\n    function borrow(\n        IERC20 collateral,\n        uint112 collateralIn,\n        bytes calldata data\n    ) internal {\n        uint256 collateralReserve = collateral.safeBalance();\n        ITimeswapBorrowCallback(msg.sender).timeswapBorrowCallback(collateralIn, data);\n        uint256 _collateralReserve = collateral.safeBalance();\n        require(_collateralReserve >= collateralReserve + collateralIn, 'E305');\n    }\n    \n    function pay(\n        IERC20 asset,\n        uint128 assetIn,\n        bytes calldata data\n    ) internal {\n        uint256 assetReserve = asset.safeBalance();\n        ITimeswapPayCallback(msg.sender).timeswapPayCallback(assetIn, data);\n        uint256 _assetReserve = asset.safeBalance();\n        require(_assetReserve >= assetReserve + assetIn, 'E304');\n    }\n}\n"
    },
    "contracts/libraries/SafeBalance.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\n\nlibrary SafeBalance {\n    using Address for address;\n\n    function safeBalance(\n        IERC20 token\n    ) internal view returns (uint256) {\n        bytes memory data =\n            address(token).functionStaticCall(\n                abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)),\n                \"Failed ERC20 balanceOf\"\n            );\n        return abi.decode(data, (uint256));\n    }\n}"
    },
    "contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\n\nlibrary SafeCast {    \n    function toUint112(uint256 x) internal pure returns (uint112 y) {\n        require(x <= type(uint112).max);\n        y = uint112(x);\n    }\n\n    function toUint128(uint256 x) internal pure returns (uint128 y) {\n        require(x <= type(uint128).max);\n        y = uint128(x);\n    }\n\n    function truncateUint112(uint256 x) internal pure returns (uint112 y) {\n        if (x > type(uint112).max) return y = type(uint112).max;\n        y = uint112(x);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/TimeswapPair.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.4;\n\nimport {IPair} from './interfaces/IPair.sol';\nimport {IFactory} from './interfaces/IFactory.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {TimeswapMath} from './libraries/TimeswapMath.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {Array} from './libraries/Array.sol';\nimport {Callback} from './libraries/Callback.sol';\nimport {BlockNumber} from './libraries/BlockNumber.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\n/// @title Timeswap Pair\n/// @author Timeswap Labs\n/// @notice It is recommended to use Timeswap Convenience to interact with this contract.\n/// @notice All error messages are coded and can be found in the documentation.\ncontract TimeswapPair is IPair, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Array for Due[];\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc IPair\n    IFactory public immutable override factory;\n    /// @inheritdoc IPair\n    IERC20 public immutable override asset;\n    /// @inheritdoc IPair\n    IERC20 public immutable override collateral;\n    /// @inheritdoc IPair\n    uint256 public immutable override fee;\n    /// @inheritdoc IPair\n    uint256 public immutable override protocolFee;\n\n    /// @inheritdoc IPair\n    uint256 public override protocolFeeStored;\n\n    /// @dev Stores the individual states of each Pool.\n    mapping(uint256 => Pool) private pools;\n\n    /* ===== VIEW =====*/\n\n    /// @inheritdoc IPair\n    function feeStored(uint256 maturity)\n        external\n        view\n        override\n        returns (uint256) \n    {\n        return pools[maturity].state.feeStored;\n    }\n\n    /// @inheritdoc IPair\n    function constantProduct(uint256 maturity)\n        external\n        view\n        override\n        returns (uint112, uint112, uint112)\n    {\n        State memory state = pools[maturity].state;\n        return (state.x, state.y, state.z);\n    }\n\n    /// @inheritdoc IPair\n    function totalReserves(uint256 maturity) external view override returns (Tokens memory) {\n        return pools[maturity].state.reserves;\n    }\n\n    /// @inheritdoc IPair\n    function totalLiquidity(uint256 maturity) external view override returns (uint256) {\n        return pools[maturity].state.totalLiquidity;\n    }\n\n    /// @inheritdoc IPair\n    function liquidityOf(uint256 maturity, address owner) external view override returns (uint256) {\n        return pools[maturity].liquidities[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalClaims(uint256 maturity) external view override returns (Claims memory) {\n        return pools[maturity].state.totalClaims;\n    }\n\n    /// @inheritdoc IPair\n    function claimsOf(uint256 maturity, address owner) external view override returns (Claims memory) {\n        return pools[maturity].claims[owner];\n    }\n\n    /// @inheritdoc IPair\n    function totalDebtCreated(uint256 maturity) external view override returns (uint120) {\n        return pools[maturity].state.totalDebtCreated;\n    }\n\n    /// @inheritdoc IPair\n    function totalDuesOf(uint256 maturity, address owner) external view override returns (uint256) {\n        return pools[maturity].dues[owner].length;\n    }\n\n    /// @inheritdoc IPair\n    function dueOf(uint256 maturity, address owner, uint256 id) external view override returns (Due memory) {\n        return pools[maturity].dues[owner][id];\n    }\n\n    /* ===== INIT ===== */\n\n    /// @dev Initializes the Pair contract.\n    /// @dev Called by the Timeswap factory contract.\n    /// @param _asset The address of the ERC20 being lent and borrowed.\n    /// @param _collateral The address of the ERC20 as the collateral.\n    /// @param _fee The chosen fee rate.\n    /// @param _protocolFee The chosen protocol fee rate.\n    constructor(\n        IERC20 _asset,\n        IERC20 _collateral,\n        uint16 _fee,\n        uint16 _protocolFee\n    ) ReentrancyGuard() {\n        factory = IFactory(msg.sender);\n        asset = _asset;\n        collateral = _collateral;\n        fee = _fee;\n        protocolFee = _protocolFee;\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc IPair\n    function mint(MintParam calldata param)\n        external\n        override\n        nonReentrant\n        returns (\n            uint256 assetIn,\n            uint256 liquidityOut,\n            uint256 id,\n            Due memory dueOut\n        )\n    {   \n        require(block.timestamp < param.maturity, 'E202');\n        unchecked { require(param.maturity - block.timestamp < 0x100000000, 'E208'); }\n        require(param.liquidityTo != address(0), 'E201');\n        require(param.dueTo != address(0), 'E201');\n        require(param.liquidityTo != address(this), 'E204');\n        require(param.dueTo != address(this), 'E204');\n        require(param.xIncrease != 0, 'E205');\n        require(param.yIncrease != 0, 'E205');\n        require(param.zIncrease != 0, 'E205');\n        \n        Pool storage pool = pools[param.maturity];\n        State memory state = pool.state;\n\n        uint256 feeStoredIncrease;\n        (liquidityOut, dueOut, feeStoredIncrease) = TimeswapMath.mint(\n            param.maturity,\n            pool.state,\n            param.xIncrease,\n            param.yIncrease,\n            param.zIncrease\n        );\n\n        require(liquidityOut != 0, 'E212');\n        state.totalLiquidity += liquidityOut;\n        pool.liquidities[param.liquidityTo] += liquidityOut;\n\n        state.feeStored += feeStoredIncrease;\n\n        id = pool.dues[param.dueTo].insert(dueOut);\n\n        state.reserves.asset += param.xIncrease;\n        state.reserves.collateral += dueOut.collateral;\n        state.totalDebtCreated += dueOut.debt;\n\n        state.x += param.xIncrease;\n        state.y += param.yIncrease;\n        state.z += param.zIncrease;\n\n        pool.state = state;\n\n        assetIn = param.xIncrease;\n        assetIn += feeStoredIncrease;\n        Callback.mint(asset, collateral, assetIn, dueOut.collateral, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Mint(\n            param.maturity, \n            msg.sender, \n            param.liquidityTo, \n            param.dueTo, \n            assetIn, \n            liquidityOut, \n            id, \n            dueOut,\n            feeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function burn(BurnParam calldata param) \n        external \n        override \n        nonReentrant \n        returns (\n            uint256 assetOut, \n            uint128 collateralOut\n        ) \n    {\n        require(block.timestamp >= param.maturity, 'E203');\n        require(param.assetTo != address(0), 'E201');\n        require(param.collateralTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.collateralTo != address(this), 'E204');\n        require(param.liquidityIn != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        State memory state = pool.state;\n        require(state.totalLiquidity != 0, 'E206');\n\n        uint128 _assetOut;\n        uint256 feeOut;\n        (_assetOut, collateralOut, feeOut) = TimeswapMath.burn(\n            pool.state,\n            param.liquidityIn\n        );\n\n        state.totalLiquidity -= param.liquidityIn;\n\n        pool.liquidities[msg.sender] -= param.liquidityIn;\n\n        assetOut = _assetOut;\n        assetOut += feeOut;\n\n        if (assetOut != 0) {\n            state.reserves.asset -= _assetOut;\n            state.feeStored -= feeOut;\n            asset.safeTransfer(param.assetTo, assetOut);\n        }\n        if (collateralOut != 0) {\n            state.reserves.collateral -= collateralOut;\n            collateral.safeTransfer(param.collateralTo, collateralOut);\n        }\n\n        pool.state = state;\n\n        emit Burn(\n            param.maturity,\n            msg.sender, \n            param.assetTo, \n            param.collateralTo, \n            param.liquidityIn, \n            assetOut, \n            collateralOut,\n            feeOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function lend(LendParam calldata param) \n        external \n        override \n        nonReentrant \n        returns (\n            uint256 assetIn,\n            Claims memory claimsOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.bondTo != address(0), 'E201');\n        require(param.insuranceTo != address(0), 'E201');\n        require(param.bondTo != address(this), 'E204');\n        require(param.insuranceTo != address(this), 'E204');\n        require(param.xIncrease != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        State memory state = pool.state;\n        require(state.totalLiquidity != 0, 'E206');\n\n        uint256 feeStoredIncrease;\n        uint256 protocolFeeStoredIncrease;\n        (claimsOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.lend(\n            param.maturity,\n            pool.state,\n            param.xIncrease,\n            param.yDecrease,\n            param.zDecrease,\n            fee,\n            protocolFee\n        );\n\n        state.feeStored += feeStoredIncrease;\n        protocolFeeStored += protocolFeeStoredIncrease;\n\n        state.totalClaims.bondPrincipal += claimsOut.bondPrincipal;\n        state.totalClaims.bondInterest += claimsOut.bondInterest;\n        state.totalClaims.insurancePrincipal += claimsOut.insurancePrincipal;\n        state.totalClaims.insuranceInterest += claimsOut.insuranceInterest;\n\n        pool.claims[param.bondTo].bondPrincipal += claimsOut.bondPrincipal;\n        pool.claims[param.bondTo].bondInterest += claimsOut.bondInterest;\n        pool.claims[param.insuranceTo].insurancePrincipal += claimsOut.insurancePrincipal;\n        pool.claims[param.insuranceTo].insuranceInterest += claimsOut.insuranceInterest;\n\n        state.reserves.asset += param.xIncrease;\n\n        state.x += param.xIncrease;\n        state.y -= param.yDecrease;\n        state.z -= param.zDecrease;\n\n        pool.state = state;\n\n        assetIn = param.xIncrease;\n        assetIn += feeStoredIncrease;\n        assetIn += protocolFeeStoredIncrease;\n\n        Callback.lend(asset, assetIn, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Lend(\n            param.maturity,\n            msg.sender, \n            param.bondTo, \n            param.insuranceTo, \n            assetIn, \n            claimsOut,\n            feeStoredIncrease,\n            protocolFeeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function withdraw(WithdrawParam calldata param)\n        external \n        override \n        nonReentrant \n        returns (\n            Tokens memory tokensOut\n        ) \n    {\n        require(block.timestamp >= param.maturity, 'E203');\n        require(param.assetTo != address(0), 'E201');\n        require(param.collateralTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.collateralTo != address(this), 'E204');\n        require(\n            param.claimsIn.bondPrincipal != 0 || \n            param.claimsIn.bondInterest != 0 ||\n            param.claimsIn.insurancePrincipal != 0 ||\n            param.claimsIn.insuranceInterest != 0, \n            'E205'\n        );\n\n        Pool storage pool = pools[param.maturity];\n        State memory state = pool.state;\n\n        tokensOut = TimeswapMath.withdraw(pool.state, param.claimsIn);\n\n        state.totalClaims.bondPrincipal -= param.claimsIn.bondPrincipal;\n        state.totalClaims.bondInterest -= param.claimsIn.bondInterest;\n        state.totalClaims.insurancePrincipal -= param.claimsIn.insurancePrincipal;\n        state.totalClaims.insuranceInterest -= param.claimsIn.insuranceInterest;\n\n        Claims memory sender = pool.claims[msg.sender];\n\n        sender.bondPrincipal -= param.claimsIn.bondPrincipal;\n        sender.bondInterest -= param.claimsIn.bondInterest;\n        sender.insurancePrincipal -= param.claimsIn.insurancePrincipal;\n        sender.insuranceInterest -= param.claimsIn.insuranceInterest;\n\n        pool.claims[msg.sender] = sender;\n\n        if (tokensOut.asset != 0) {\n            state.reserves.asset -= tokensOut.asset;\n            asset.safeTransfer(param.assetTo, tokensOut.asset);\n        }\n        if (tokensOut.collateral != 0) {\n            state.reserves.collateral -= tokensOut.collateral;\n            collateral.safeTransfer(param.collateralTo, tokensOut.collateral);\n        }\n\n        pool.state = state;\n\n        emit Withdraw(\n            param.maturity,\n            msg.sender, \n            param.assetTo, \n            param.collateralTo, \n            param.claimsIn, \n            tokensOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function borrow(BorrowParam calldata param)\n        external \n        override \n        nonReentrant \n        returns (\n            uint256 assetOut,\n            uint256 id, \n            Due memory dueOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.assetTo != address(0), 'E201');\n        require(param.dueTo != address(0), 'E201');\n        require(param.assetTo != address(this), 'E204');\n        require(param.dueTo != address(this), 'E204');\n        require(param.xDecrease != 0, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n        State memory state = pool.state;\n        require(state.totalLiquidity != 0, 'E206');\n\n        uint256 feeStoredIncrease;\n        uint256 protocolFeeStoredIncrease;\n        (dueOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.borrow(\n            param.maturity,\n            pool.state,\n            param.xDecrease,\n            param.yIncrease,\n            param.zIncrease,\n            fee,\n            protocolFee\n        );\n\n        state.feeStored += feeStoredIncrease;\n        protocolFeeStored += protocolFeeStoredIncrease;\n\n        id = pool.dues[param.dueTo].insert(dueOut);\n\n        state.reserves.asset -= param.xDecrease;\n        state.reserves.collateral += dueOut.collateral;\n        state.totalDebtCreated += dueOut.debt;\n\n        state.x -= param.xDecrease;\n        state.y += param.yIncrease;\n        state.z += param.zIncrease;\n\n        pool.state = state;\n\n        assetOut = param.xDecrease;\n        assetOut -= feeStoredIncrease;\n        assetOut -= protocolFeeStoredIncrease;\n\n        asset.safeTransfer(param.assetTo, assetOut);\n\n        Callback.borrow(collateral, dueOut.collateral, param.data);\n\n        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);\n        emit Borrow(\n            param.maturity, \n            msg.sender, \n            param.assetTo, \n            param.dueTo, \n            assetOut, \n            id, \n            dueOut,\n            feeStoredIncrease,\n            protocolFeeStoredIncrease\n        );\n    }\n\n    /// @inheritdoc IPair\n    function pay(PayParam calldata param)\n        external \n        override \n        nonReentrant \n        returns (\n            uint128 assetIn, \n            uint128 collateralOut\n        ) \n    {\n        require(block.timestamp < param.maturity, 'E202');\n        require(param.owner != address(0), 'E201');\n        require(param.to != address(0), 'E201');\n        require(param.to != address(this), 'E204');\n        \n        uint256 length = param.ids.length;\n        require(length== param.assetsIn.length, 'E205');\n        require(length == param.collateralsOut.length, 'E205');\n\n        Pool storage pool = pools[param.maturity];\n\n        Due[] storage dues = pool.dues[param.owner];\n        require(dues.length >= length, 'E205');\n\n        for (uint256 i; i < length;) {\n            Due storage due = dues[param.ids[i]];\n            require(due.startBlock != BlockNumber.get(), 'E207');\n\n            uint112 _assetIn = param.assetsIn[i];\n            uint112 _collateralOut = param.collateralsOut[i];\n\n            if (param.owner != msg.sender) require(_collateralOut == 0, 'E213');\n            require(uint256(_assetIn) * due.collateral >= uint256(_collateralOut) * due.debt, 'E303');\n            \n            due.debt -= _assetIn;\n            due.collateral -= _collateralOut;\n            assetIn += _assetIn;\n            collateralOut += _collateralOut;\n\n            unchecked { ++i; }\n        }\n\n        pool.state.reserves.asset += assetIn;\n        pool.state.reserves.collateral -= collateralOut;\n\n        if (collateralOut != 0) collateral.safeTransfer(param.to, collateralOut);\n\n        if (assetIn != 0) Callback.pay(asset, assetIn, param.data);\n\n        emit Pay(\n            param.maturity, \n            msg.sender, \n            param.to, \n            param.owner, \n            param.ids, \n            param.assetsIn, \n            param.collateralsOut, \n            assetIn, \n            collateralOut\n        );\n    }\n\n    /// @inheritdoc IPair\n    function collectProtocolFee(address to) external override nonReentrant returns (uint256 protocolFeeOut) {\n        require(msg.sender == factory.owner(), 'E216');\n        require(to != address(0), 'E201');\n\n        protocolFeeOut = protocolFeeStored;\n        protocolFeeStored = 0;\n\n        asset.safeTransfer(to, protocolFeeOut);\n\n        emit CollectProtocolFee(msg.sender, to, protocolFeeOut);\n    }\n}\n"
    },
    "contracts/libraries/TimeswapMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.4;\n\nimport {IPair} from '../interfaces/IPair.sol';\nimport {Math} from './Math.sol';\nimport {FullMath} from './FullMath.sol';\nimport {ConstantProduct} from './ConstantProduct.sol';\nimport {SafeCast} from './SafeCast.sol';\nimport {BlockNumber} from './BlockNumber.sol';\n\nlibrary TimeswapMath {\n    using Math for uint256;\n    using FullMath for uint256;\n    using ConstantProduct for IPair.State;\n    using SafeCast for uint256;\n\n    uint256 private constant BASE = 0x10000000000;\n\n    function mint(\n        uint256 maturity,\n        IPair.State memory state,\n        uint112 xIncrease, \n        uint112 yIncrease, \n        uint112 zIncrease\n    ) \n        external \n        view \n        returns(\n            uint256 liquidityOut,\n            IPair.Due memory dueOut,\n            uint256 feeStoredIncrease\n        )\n    {\n        if (state.totalLiquidity == 0) {\n            liquidityOut = xIncrease;\n            liquidityOut <<= 16;\n        } else {\n            uint256 fromX = state.totalLiquidity.mulDiv(xIncrease, state.x);\n            uint256 fromY = state.totalLiquidity.mulDiv(yIncrease, state.y);\n            uint256 fromZ = state.totalLiquidity.mulDiv(zIncrease, state.z);\n\n            require(fromY <= fromX,'E214');\n            require(fromZ <= fromX, 'E215');\n\n            liquidityOut = fromY <= fromZ ? fromY : fromZ;\n\n            feeStoredIncrease = state.feeStored.mulDivUp(liquidityOut, state.totalLiquidity);\n        }\n\n        uint256 _debtIn = maturity;\n        _debtIn -= block.timestamp;\n        _debtIn *= yIncrease;\n        _debtIn = _debtIn.shiftRightUp(32);\n        _debtIn += xIncrease;\n        dueOut.debt = _debtIn.toUint112();\n\n        uint256 _collateralIn = maturity;\n        _collateralIn -= block.timestamp; \n        _collateralIn *= zIncrease;\n        _collateralIn = _collateralIn.shiftRightUp(25); \n        _collateralIn += zIncrease; \n        dueOut.collateral = _collateralIn.toUint112();\n\n        dueOut.startBlock = BlockNumber.get();\n    }\n\n    function burn(\n        IPair.State memory state,\n        uint256 liquidityIn\n    )\n        external\n        pure\n        returns (\n            uint128 assetOut,\n            uint128 collateralOut,\n            uint256 feeOut\n        )\n    {\n        uint256 totalAsset = state.reserves.asset;\n        uint256 totalCollateral = state.reserves.collateral;\n        uint256 totalBond = state.totalClaims.bondPrincipal;\n        totalBond += state.totalClaims.bondInterest;\n\n        if (totalAsset >= totalBond) {\n            uint256 _assetOut = totalAsset;\n            unchecked { _assetOut -= totalBond; }\n            _assetOut = _assetOut.mulDiv(liquidityIn, state.totalLiquidity);\n            assetOut = _assetOut.toUint128();\n\n            uint256 _collateralOut = totalCollateral;\n            _collateralOut = _collateralOut.mulDiv(liquidityIn, state.totalLiquidity);\n            collateralOut = _collateralOut.toUint128();\n        } else {\n            uint256 deficit = totalBond;\n            unchecked { deficit -= totalAsset; }\n\n            uint256 totalInsurance = state.totalClaims.insurancePrincipal;\n            totalInsurance += state.totalClaims.insuranceInterest;\n\n            if (totalCollateral * totalBond > deficit * totalInsurance) {\n                uint256 _collateralOut = totalCollateral;\n                uint256 subtrahend = deficit;\n                subtrahend *= totalInsurance;\n                subtrahend = subtrahend.divUp(totalBond);\n                _collateralOut -= subtrahend;\n                _collateralOut = _collateralOut.mulDiv(liquidityIn, state.totalLiquidity);\n                collateralOut = _collateralOut.toUint128();\n            }\n        }\n\n        feeOut = state.feeStored.mulDiv(liquidityIn, state.totalLiquidity);\n    }\n\n    function lend(\n        uint256 maturity,\n        IPair.State memory state,\n        uint112 xIncrease,\n        uint112 yDecrease,\n        uint112 zDecrease,\n        uint256 fee,\n        uint256 protocolFee\n    )\n        external\n        view\n        returns (\n            IPair.Claims memory claimsOut,\n            uint256 feeStoredIncrease,\n            uint256 protocolFeeStoredIncrease\n        ) \n    {   \n        lendCheck(state, xIncrease, yDecrease, zDecrease);\n\n        claimsOut.bondPrincipal = xIncrease;\n        claimsOut.bondInterest = getBondInterest(maturity, yDecrease);\n        claimsOut.insurancePrincipal = getInsurancePrincipal(state, xIncrease);\n        claimsOut.insuranceInterest = getInsuranceInterest(maturity, zDecrease);\n\n        (feeStoredIncrease, protocolFeeStoredIncrease) = lendGetFees(\n            maturity,\n            xIncrease,\n            fee,\n            protocolFee\n        );\n    }\n\n    function lendCheck(\n        IPair.State memory state,\n        uint112 xIncrease,\n        uint112 yDecrease,\n        uint112 zDecrease\n    ) private pure {\n        uint112 xReserve = state.x + xIncrease;\n        uint112 yReserve = state.y - yDecrease;\n        uint112 zReserve = state.z - zDecrease;\n        state.checkConstantProduct(xReserve, yReserve, zReserve);\n\n        uint256 yMin = xIncrease;\n        yMin *= state.y;\n        yMin /= xReserve;\n        yMin >>= 4;\n        require(yDecrease >= yMin, 'E217');\n    }\n\n    function getBondInterest(\n        uint256 maturity,\n        uint112 yDecrease\n    ) private view returns (uint112 bondInterestOut) {\n        uint256 _bondInterestOut = maturity;\n        _bondInterestOut -= block.timestamp;\n        _bondInterestOut *= yDecrease;\n        _bondInterestOut >>= 32;\n        bondInterestOut = _bondInterestOut.toUint112();\n    }\n\n    function getInsurancePrincipal(\n        IPair.State memory state,\n        uint112 xIncrease\n    ) private pure returns (uint112 insurancePrincipalOut) {\n        uint256 _insurancePrincipalOut = state.z;\n        _insurancePrincipalOut *= xIncrease;\n        uint256 denominator = state.x;\n        denominator += xIncrease;\n        _insurancePrincipalOut /= denominator;\n        insurancePrincipalOut = _insurancePrincipalOut.toUint112();\n    }\n\n    function getInsuranceInterest(\n        uint256 maturity,\n        uint112 zDecrease\n    ) private view returns (uint112 insuranceInterestOut) {\n        uint256 _insuranceInterestOut = maturity;\n        _insuranceInterestOut -= block.timestamp;\n        _insuranceInterestOut *= zDecrease;\n        _insuranceInterestOut >>= 25;\n        insuranceInterestOut = _insuranceInterestOut.toUint112();\n    }\n\n    function lendGetFees(\n        uint256 maturity,\n        uint112 xIncrease,\n        uint256 fee,\n        uint256 protocolFee\n    ) private view returns (\n        uint256 feeStoredIncrease,\n        uint256 protocolFeeStoredIncrease\n        )\n    {\n        uint256 totalFee = fee;\n        totalFee += protocolFee;\n\n        uint256 numerator = maturity;\n        numerator -= block.timestamp;\n        numerator *= totalFee;\n        numerator += BASE;\n\n        uint256 adjusted = xIncrease;\n        adjusted *= numerator;\n        adjusted = adjusted.divUp(BASE);\n        uint256 totalFeeStoredIncrease = adjusted;\n        unchecked { totalFeeStoredIncrease -= xIncrease; }\n\n        feeStoredIncrease = totalFeeStoredIncrease;\n        feeStoredIncrease *= fee;\n        feeStoredIncrease /= totalFee;\n        protocolFeeStoredIncrease = totalFeeStoredIncrease;\n        unchecked { protocolFeeStoredIncrease -= feeStoredIncrease; }\n    }\n\n    function withdraw(\n        IPair.State memory state,\n        IPair.Claims memory claimsIn\n    ) external pure returns (IPair.Tokens memory tokensOut) {\n        uint256 totalAsset = state.reserves.asset;\n        uint256 totalBondPrincipal = state.totalClaims.bondPrincipal;\n        uint256 totalBondInterest = state.totalClaims.bondInterest;\n        uint256 totalBond = totalBondPrincipal;\n        totalBond += totalBondInterest;\n\n        if (totalAsset >= totalBond) {\n            tokensOut.asset = claimsIn.bondPrincipal;\n            tokensOut.asset += claimsIn.bondInterest;\n        } else {\n            if (totalAsset >= totalBondPrincipal) {\n                uint256 remaining = totalAsset;\n                unchecked { remaining -= totalBondPrincipal; }\n                uint256 _assetOut = claimsIn.bondInterest;\n                _assetOut *= remaining;\n                _assetOut /= totalBondInterest;\n                _assetOut += claimsIn.bondPrincipal;\n                tokensOut.asset = _assetOut.toUint128();\n            } else {\n                uint256 _assetOut = claimsIn.bondPrincipal;\n                _assetOut *= totalAsset;\n                _assetOut /= totalBondPrincipal;\n                tokensOut.asset = _assetOut.toUint128();\n            }\n            \n            uint256 deficit = totalBond;\n            unchecked { deficit -= totalAsset; }\n\n            uint256 totalInsurancePrincipal = state.totalClaims.insurancePrincipal;\n            totalInsurancePrincipal *= deficit;\n            uint256 totalInsuranceInterest = state.totalClaims.insuranceInterest;\n            totalInsuranceInterest *= deficit;\n            uint256 totalInsurance = totalInsurancePrincipal;\n            totalInsurance += totalInsuranceInterest;\n\n            uint256 totalCollateral = state.reserves.collateral;\n            totalCollateral *= totalBond;\n\n            if (totalCollateral >= totalInsurance) {\n                uint256 _collateralOut = claimsIn.insurancePrincipal;\n                _collateralOut += claimsIn.insuranceInterest;\n                _collateralOut *= deficit;\n                _collateralOut /= totalBond;\n                tokensOut.collateral = _collateralOut.toUint128();\n            } else if (totalCollateral >= totalInsurancePrincipal) {\n                uint256 remaining = totalCollateral;\n                unchecked { remaining -= totalInsurancePrincipal; }\n                uint256 _collateralOut = claimsIn.insuranceInterest;\n                _collateralOut *= deficit;\n                uint256 denominator = totalInsuranceInterest;\n                denominator *= totalBond;\n                _collateralOut = _collateralOut.mulDiv(remaining, denominator);\n                uint256 addend = claimsIn.insurancePrincipal;\n                addend *= deficit;\n                addend /= totalBond;\n                _collateralOut += addend;\n                tokensOut.collateral = _collateralOut.toUint128();\n            } else {\n                uint256 _collateralOut = claimsIn.insurancePrincipal;\n                _collateralOut *= deficit;\n                uint256 denominator = totalInsurancePrincipal;\n                denominator *= totalBond;\n                _collateralOut = _collateralOut.mulDiv(totalCollateral, denominator);\n                tokensOut.collateral = _collateralOut.toUint128();\n            }\n        }\n    }\n\n    function borrow(\n        uint256 maturity,\n        IPair.State memory state,\n        uint112 xDecrease,\n        uint112 yIncrease,\n        uint112 zIncrease,\n        uint256 fee,\n        uint256 protocolFee\n    )\n        external\n        view\n        returns (\n            IPair.Due memory dueOut,\n            uint256 feeStoredIncrease,\n            uint256 protocolFeeStoredIncrease\n        )\n    {\n        borrowCheck(state, xDecrease, yIncrease, zIncrease);\n\n        dueOut.debt = getDebt(maturity, xDecrease, yIncrease);\n        dueOut.collateral = getCollateral(maturity, state, xDecrease, zIncrease);\n        dueOut.startBlock = BlockNumber.get();\n\n        (feeStoredIncrease, protocolFeeStoredIncrease) = borrowGetFees(\n            maturity,\n            xDecrease,\n            fee,\n            protocolFee\n        );\n    }\n\n    function borrowCheck(\n        IPair.State memory state,\n        uint112 xDecrease,\n        uint112 yIncrease,\n        uint112 zIncrease\n    ) private pure {\n        uint112 xReserve = state.x - xDecrease;\n        uint112 yReserve = state.y + yIncrease;\n        uint112 zReserve = state.z + zIncrease;\n        state.checkConstantProduct(xReserve, yReserve, zReserve);\n\n        uint256 yMax = xDecrease;\n        yMax *= state.y;\n        yMax = yMax.divUp(xReserve);\n        require(yIncrease <= yMax, 'E214');\n\n        uint256 zMax = xDecrease;\n        zMax *= state.z;\n        zMax = zMax.divUp(xReserve);\n        require(zIncrease <= zMax, 'E215');\n\n        uint256 yMin = yMax;\n        yMin = yMin.shiftRightUp(4);\n        require(yIncrease >= yMin, 'E217');\n    }\n\n    function getDebt(\n        uint256 maturity,\n        uint112 xDecrease,\n        uint112 yIncrease\n    ) private view returns (uint112 debtIn) {\n        uint256 _debtIn = maturity;\n        _debtIn -= block.timestamp;\n        _debtIn *= yIncrease;\n        _debtIn = _debtIn.shiftRightUp(32);\n        _debtIn += xDecrease;\n        debtIn = _debtIn.toUint112();\n    }\n\n    function getCollateral(\n        uint256 maturity,\n        IPair.State memory state,\n        uint112 xDecrease,\n        uint112 zIncrease\n    ) private view returns (uint112 collateralIn) {\n        uint256 _collateralIn = maturity;\n        _collateralIn -= block.timestamp;\n        _collateralIn *= zIncrease;\n        _collateralIn = _collateralIn.shiftRightUp(25);\n        uint256 minimum = state.z;\n        minimum *= xDecrease;\n        uint256 denominator = state.x;\n        denominator -= xDecrease;\n        minimum = minimum.divUp(denominator);\n        _collateralIn += minimum;\n        collateralIn = _collateralIn.toUint112();\n    }\n\n    function borrowGetFees(\n        uint256 maturity,\n        uint112 xDecrease,\n        uint256 fee,\n        uint256 protocolFee\n    ) private view returns (\n            uint256 feeStoredIncrease,\n            uint256 protocolFeeStoredIncrease\n        )\n    {\n\n        uint256 totalFee = fee;\n        totalFee += protocolFee;\n\n        uint256 denominator = maturity;\n        denominator -= block.timestamp;\n        denominator *= totalFee;\n        denominator += BASE;\n\n        uint256 adjusted = xDecrease;\n        adjusted *= BASE;\n        adjusted /= denominator;\n        uint256 totalFeeStoredIncrease = xDecrease;\n        unchecked { totalFeeStoredIncrease -= adjusted; }\n\n        feeStoredIncrease = totalFeeStoredIncrease;\n        feeStoredIncrease *= fee;\n        feeStoredIncrease /= totalFee;\n        protocolFeeStoredIncrease = totalFeeStoredIncrease;\n        unchecked { protocolFeeStoredIncrease -= feeStoredIncrease; }\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/libraries/Array.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\n\nimport {IPair} from '../interfaces/IPair.sol';\n\nlibrary Array {\n    function insert(IPair.Due[] storage dues, IPair.Due memory dueOut) internal returns (uint256 id) {\n        id = dues.length;   \n        \n        dues.push(dueOut);\n        \n    }\n}"
    },
    "contracts/libraries/BlockNumber.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\n\nlibrary BlockNumber {\n    function get() internal view returns (uint32 blockNumber) {\n        // can overflow\n        blockNumber = uint32(block.number);\n    }\n}"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\n\nlibrary Math {\n    function divUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x / y;\n        if (x % y != 0) z++;\n    }\n\n    function shiftRightUp(uint256 x, uint8 y) internal pure returns (uint256 z) {\n        z = x >> y;\n        if (x != z << y) z++;\n    }\n\n}\n"
    },
    "contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nlibrary FullMath {\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 prod0, uint256 prod1) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n    }\n    \n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 prod0, uint256 prod1) = mul512(a, b);\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator != 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos;\n            twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;    \n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv;\n            inv = (3 * denominator) ^ 2;\n\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) != 0) result++;\n    }\n}"
    },
    "contracts/libraries/ConstantProduct.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.4;\n\nimport {IPair} from '../interfaces/IPair.sol';\nimport {FullMath} from './FullMath.sol';\n\nlibrary ConstantProduct {\n    using FullMath for uint256;\n\n    function checkConstantProduct(\n        IPair.State memory state,\n        uint112 xReserve,\n        uint128 yAdjusted,\n        uint128 zAdjusted\n    ) internal pure {\n\n        (uint256 prod0, uint256 prod1) = (uint256(yAdjusted) * zAdjusted).mul512(xReserve);\n        (uint256 _prod0, uint256 _prod1) = ((uint256(state.y) * state.z)).mul512(state.x);\n\n        require(prod1 >= _prod1, 'E301');\n        if (prod1 == _prod1) require(prod0 >= _prod0, 'E301');\n    }\n}\n"
    },
    "contracts/test/libraries/BlockNumberTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.4;\n\nimport {BlockNumber} from '../../libraries/BlockNumber.sol';\n\nlibrary BlockNumberTest {\n    function get() external view returns (uint32 blockNumber) {\n        return BlockNumber.get();\n    }\n}"
    },
    "contracts/test/libraries/TimeswapMathTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.4;\n\nimport {TimeswapMath} from '../../libraries/TimeswapMath.sol';\nimport {IPair} from '../../interfaces/IPair.sol';\n\ncontract TimeswapMathTest {\n\n    function mint(\n        uint256 maturity,\n        IPair.State memory state,\n        uint112 xIncrease, \n        uint112 yIncrease, \n        uint112 zIncrease\n    ) external \n        view \n        returns(\n            uint256 liquidityOut,\n            IPair.Due memory dueOut,\n            uint256 feeStoredIncrease\n        ) {\n            return TimeswapMath.mint(\n            maturity,\n            state,\n            xIncrease, \n            yIncrease, \n            zIncrease \n            );\n        }\n\n    function burn(\n        IPair.State memory state,\n        uint256 liquidityIn\n    )\n        external\n        pure\n        returns (\n            uint128 assetOut,\n            uint128 collateralOut,\n            uint256 feeOut\n        ) {\n            return TimeswapMath.burn(state, liquidityIn);\n        }\n    \n    function lend(\n        uint256 maturity,\n        IPair.State memory state,\n        uint112 xIncrease,\n        uint112 yDecrease,\n        uint112 zDecrease,\n        uint256 fee,\n        uint256 protocolFee\n    )\n        external\n        view\n        returns (\n            IPair.Claims memory claimsOut,\n            uint256 feeStoredIncrease,\n            uint256 protocolFeeStoredIncrease\n        ) {\n            return TimeswapMath.lend(maturity, state, xIncrease, yDecrease, zDecrease, fee, protocolFee);\n        }\n\n    function withdraw(\n        IPair.State memory state,\n        IPair.Claims memory claimsIn\n    ) external pure returns (IPair.Tokens memory tokensOut) {\n        return TimeswapMath.withdraw(state, claimsIn);\n    }\n\n    function borrow(\n        uint256 maturity,\n        IPair.State memory state,\n        uint112 xDecrease,\n        uint112 yIncrease,\n        uint112 zIncrease,\n        uint256 fee,\n        uint256 protocolFee\n    )\n        external\n        view\n        returns (\n            IPair.Due memory dueOut,\n            uint256 feeStoredIncrease,\n            uint256 protocolFeeStoredIncrease\n        )\n        {\n            return TimeswapMath.borrow(maturity, state, xDecrease, yIncrease, zIncrease, fee, protocolFee);\n        }\n}"
    },
    "contracts/TimeswapFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.4;\n\nimport {IFactory} from './interfaces/IFactory.sol';\nimport {IPair} from './interfaces/IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {TimeswapPair} from './TimeswapPair.sol';\n\n/// @title Timeswap Factory\n/// @author Timeswap Labs\n/// @notice It is recommended to use Timeswap Convenience to interact with this contract.\n/// @notice All error messages are coded and can be found in the documentation.\ncontract TimeswapFactory is IFactory {\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc IFactory\n    address public override owner;\n    /// @inheritdoc IFactory\n    address public override pendingOwner;\n    /// @inheritdoc IFactory\n    uint256 public immutable override fee;\n    /// @inheritdoc IFactory\n    uint256 public immutable override protocolFee;\n\n    /// @inheritdoc IFactory\n    mapping(IERC20 => mapping(IERC20 => IPair)) public override getPair;\n\n    /* ===== INIT ===== */\n\n    /// @param _owner The chosen owner address.\n    /// @param _fee The chosen fee rate.\n    /// @param _protocolFee The chosen protocol fee rate.\n    constructor(\n        address _owner,\n        uint16 _fee,\n        uint16 _protocolFee\n    ) {\n        require(_owner != address(0), 'E101');\n        require(_fee != 0);\n        require(_protocolFee != 0);\n        owner = _owner;\n        fee = _fee;\n        protocolFee = _protocolFee;\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc IFactory\n    function createPair(IERC20 asset, IERC20 collateral) external override returns (IPair pair) {\n        require(asset != collateral, 'E103');\n        require(asset != IERC20(address(0)), 'E101');\n        require(collateral != IERC20(address(0)), 'E101');\n        require(getPair[asset][collateral] == IPair(address(0)), 'E104');\n\n        pair = new TimeswapPair{salt: keccak256(abi.encode(asset, collateral))}(asset, collateral, uint16(fee), uint16(protocolFee));\n\n        getPair[asset][collateral] = pair;\n\n        emit CreatePair(asset, collateral, pair);\n    }\n\n    /// @inheritdoc IFactory\n    function setPendingOwner(address _pendingOwner) external override {\n        require(msg.sender == owner, 'E102');\n        require(_pendingOwner != address(0), 'E101');\n        pendingOwner = _pendingOwner;\n\n        emit SetOwner(_pendingOwner);\n    }\n\n    /// @inheritdoc IFactory\n    function acceptOwner() external override {\n        require(msg.sender == pendingOwner, 'E102');\n        owner = msg.sender;\n        pendingOwner = address(0);\n\n        emit AcceptOwner(msg.sender);\n    }\n}\n"
    },
    "contracts/test/libraries/SafeBalanceTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.4;\n\nimport {SafeBalance} from '../../libraries/SafeBalance.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract SafeBalanceTest {\n    function safeBalance(\n        IERC20 token\n    ) external view returns (uint256) {\n        return SafeBalance.safeBalance(token);\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/test/TestToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.1;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract TestToken is ERC20 {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 amount\n    ) ERC20(name_, symbol_) {\n        _mint(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/test/libraries/ConstantProductTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.4;\n\nimport {ConstantProduct} from '../../libraries/ConstantProduct.sol';\nimport {IPair} from '../../interfaces/IPair.sol';\n\ncontract ConstantProductTest {\n    using ConstantProduct for IPair.State;\n\n    function checkConstantProduct(\n        IPair.State memory state,\n        uint112 xReserve,\n        uint128 yAdjusted,\n        uint128 zAdjusted\n    ) external pure returns(bool){\n        state.checkConstantProduct(\n            xReserve,\n            yAdjusted,\n            zAdjusted\n        );\n        return true;\n    }\n}"
    },
    "contracts/test/libraries/ArrayTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.4;\n\nimport {Array} from '../../libraries/Array.sol';\nimport {IPair} from '../../interfaces/IPair.sol';\n\ncontract ArrayTest {\n    using Array for IPair.Due[];\n\n    IPair.Due[] public duesStorage;\n    \n    function insert(\n        IPair.Due[] calldata dues,\n        IPair.Due memory dueOut\n    ) external returns (uint256 id) {\n        for (uint256 i; i < duesStorage.length; i++) duesStorage.pop;\n        \n        for (uint256 i; i < dues.length; i++) {\n            duesStorage.push(dues[i]);\n        }\n\n        return duesStorage.insert(dueOut);\n    }\n}"
    },
    "contracts/test/libraries/SafeCastTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.4;\n\nimport {SafeCast} from '../../libraries/SafeCast.sol';\n\ncontract SafeCastTest {\n    \n    function toUint112(uint256 x) external pure returns (uint112 y) {\n        return SafeCast.toUint112(x);\n    }\n\n    function toUint128(uint256 x) external pure returns (uint128 y) {\n        return SafeCast.toUint128(x);\n    }\n\n    function truncateUint112(uint256 x) external pure returns (uint112 y) {\n        return SafeCast.truncateUint112(x);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}